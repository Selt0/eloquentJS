
//CHAPTER 4 - DATA STRUCTURES AND OBJECT ARRAYS

When you compare objects with JavaScript’s == operator, it compares by identity: it will produce true only if both objects are precisely the same value. Comparing different objects will return false, even if they have identical properties.

let object1 = {value: 10};
let object2 = object1;
let object3 = {value: 10};

console.log(object1 == object2);
// -> true
console.log(object1 == object3);
// -> false

'object2' is set to equal 'object1', which gives it the same identity. 

const binding to an object allows the values to change but the binding to the object itself cannot change

const score = {visitors: 0, home: 0};
score.visitors = 1;

//error
score = {visitor: 1, home: 1};
- - - - - - - - - - - -  - - - -
//empty array
let jounral = []; 

function addEntry(events, squirrel) {
  journal.push({events, squirrel});
}

Note that the object added to the journal looks a little odd. Instead of declaring properties like events: events, it just gives a property name. This is shorthand that means the same thing—if a property name in brace notation isn’t followed by a value, its value is taken from the binding with the same name.

//Array Loops
for (let i = 0; i < journal.length; i++) {
  let entry = journal[i];
}
//mordern loop in JS
for (let entry of journal) {
  console.log(`${entry.events.length} events.`)
}

//CHAPTER 5

//reduce()

const array1 = [1, 2, 3, 4];
let reducer = (accumulator, currentValue) => accumulator + currentValue;

// 1 + 2 + 3 + 4
console.log(array1.reduce(reducer));
// -> 10

// 5 + 1 + 2 + 3 + 4
console.log(array1.reduce(reducer, 5));
// ->  15

- - - - - - - - - - - - -

let vals = [5, 4, 1, 2, 9];
let acc = 0;
for (let val of vals) {
  acc += val;
}
console.log(acc);
// -> 21

function sum(acc, val) {   arrow function  (acc, val) => acc + val
  return acc + val;           ---- > 
}  

let answer = vals.reduce(sum);
let answer = vals.reduce((acc, val) => acc + val);
console.log(answer);
// -> 21

let answer10 = vals.reduce(sum, 10);
console.log(answer10);
// -> 31

let answer10 = vals.reduce((acc, val) => {
  return acc + val
}, 10)
// -> 31
- - - - - - - - - - - - -


function reduce(array, combine, start) {
  let current = start;
  for (let element of array) {
    current = combine(current, element);
  }
  return current;
}

console.log(reduce([1, 2, 3, 4], (a, b) => a + b, 0));
// -> 10

- - - - - - - - - - - - - - - -

//flatten an array of arrays
let flattened = [[0, 1], [2, 3], [4, 5]].reduce (
  function(accumulator, currentValue) {
    return accumulator.concat(currentValue)
  }, []);

let flattened = [[0, 1], [2, 3], [4, 5]].reduce (
  (accumulator, currentValue) => accumulator.concat(currentValue), 
  [])

- - - - - - - - - - - - - - - -

If no initial value is given, the first element of the array will be the accumulator.

accumulator is the result of the loop.
[2,1,4,5,9,7]
let biggest = vals.reduce((a, b) => b > a ? b : a);

Step 1: accumulator is 2 (because no initial value)
Step 2: is 1 > 2? no. accumulator remains 2;
step 3: is 4 > 2? yes. accumulator is now 4;
step 5: is 5 > 4? yes. accumulator is now 5;
step 6: is 9 > 5? yes, accumulator is now 9;
step 7: is 7 > 9? no. accumulator remains 9;
