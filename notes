//CHAPTER 3 FUNCTION --NOTES

//Define f to hold a function value
const f = function(a) {
  console.log(a + 2);
};

//Declare g to be a function (doesn't requier a semicolon at the end)
function g(a, b) {
  return a * b * 3.5;
}

//A more simple function value
let f = a => console.log(a + 2);

//arrow functions (to write small functions)
When there is only one parameter name, you can leave out the paranthesis. If the body of the function is a single expression, not a block, the expression will be returned

const square1 = (x) => {return x * x; };
const sqaure2 = x => x * x;

//function with no parameter
const horn = () => {
  console.log('Toot');
};

//call stack
When calling a function, the computer has to jump to the place where the function is created. The computer stores its spot, called a call stack. When the computer returns, it removes the stack and continues. 

Storing the call stack requires space in the computer's memory. When the stack grows too big, the computer will fail with a message such as "out of stack space" or "too much recursion." Causing an infinite back-and-forth will "blow the stack"

function chicken() {
  return  egg();
}
function egg() {
  return chicken();
}
console.log(chicken() + " came first.");

//optional arguments
JS is very linient when it comes to parameters. 

If you pass too many, the extra ones are ignored. 
function square(x) { return x * x; }
console.log(square(4, true, 'apple'));
// -> 16

if you pass too few, the missing parameters get assigned the value undefined
function minus(a, b) {
  if (b === undefined) return -a;
  else return a - b;
}
console.log(minus(10));
// -> -10
console.log(minus(10, 5));
// -> 5

you can give the optional argument a default value
function power(base, exponent = 2) { 
let result = 1;
for (let count = 0; count < exponent; count++) {
  return *= base;
  }
return result;
}
console.log(power(4));
// -> 16
console.log(power(2, 6));
// -> 64

*Think of function values as containing both the code in their body and the environment in which they are created.*

When called, the function body sees the environment in which it was created, not the environment in which it is called.
function multiplier(factor) {
  return number => number * factor;
}
let twice = multiplier(2);
console.log(twice(5));
// -> 10

//recursion - a function that calls itself
function findSolution(target) {
  function find(current, history) {
    if (current == target) {
      return history;
    } else if (current > target) {
      return null;
    } else {
      return  find(current + 5, `(${history} + 5)`) || 
              find (current * 3, `(${history} * 3)`);
    }
  }
  return find(1, '1');
}
console.log(findSolution(13));
// -> (((1 * 3) + 5) + 5)

find(1, "1")
  find(6, "(1 + 5)")
    find(11, "((1 + 5) + 5)")
      find(16, "(((1 + 5) + 5) + 5)")
        too big
      find(33, "(((1 + 5) + 5) * 3)")
        too big
    find(18, "((1 + 5) * 3)")
      too big
  find(3, "(1 * 3)")
    find(8, "((1 * 3) + 5)")
      find(13, "(((1 * 3) + 5) + 5)")
        found!

When writing code, always start with something that's correct and easy to understand. Worry about efficiency afterward and improve it if necessary. 

*There are two or more less natural ways for a function to be introduced*

1. You find yourself wrting similar code multiple times. DRY (don't repeat yourself!). More code = more chances for errors and more material to read for people trying to understand the program.
-- Take the repeated functionality, find a good name for it, and make a function

2. You find you need some functionality that you haven't written yet and it sounds like it deserves its own function. You'll start by naming the function, and then write its body. You might even start wrting code that uses the function before you actually define the function

*How difficult it is to find a good name for a function is a good indication of how clear a concept it is that you're trying to wrap*

function printZeroPaddedWithLabel(number, label) {
  let numberString = String(number);
  while (numberString.length < 3) {
    numberString ='0' + numberString;
  }
  console.log(`${numberString} ${label}`);
}

function printFarmInventory(cows, chickens. pigs) {
  printZeroPaddedWithLabel(cows, 'Cows');
  printZeroPaddedWithLabel(chickens, 'Chickens');
  printZeroPaddedWithLabel(pigs, 'Pigs');
}
printFarmInventory(7, 11, 3);

-- VS --

function zeroPad(number, width) {
  let string = String(number);
  while (string.length < width) {
    string = '0' + string;
  }
  return string;
}

function printFarmInventory(cows, chickens, pigs) {
  console.log(`${zeroPad(cows, 3)} Cows`);
  console.log(`${zeroPad(chickens, 3)} Chickens`);
  console.log(`${zeroPad(pigs, 3)} Pigs`);
}
printFarmInventory(7, 11, 3);

A function with a nice, obvious name like zeroPad makes it easier for someone who reads the code to figure out what it does. And such a function is useful in more situations than just this specific program. For example, you could use it to help print nicely aligned tables of numbers.

*A useful principle is to not add cleverness unless you are absolutely sure you’re going to need it. It can be tempting to write general “frameworks” for every bit of functionality you come across. Resist that urge. You won’t get any real work done—you’ll just be writing code that you never use.*

Separating the tasks your program performs into different functions is helpful. You won’t have to repeat yourself as much, and functions can help organize a program by grouping code into pieces that do specific things.

//CHAPTER 4 - DATA STRUCTURES AND OBJECT ARRAYS

When you compare objects with JavaScript’s == operator, it compares by identity: it will produce true only if both objects are precisely the same value. Comparing different objects will return false, even if they have identical properties.

let object1 = {value: 10};
let object2 = object1;
let object3 = {value: 10};

console.log(object1 == object2);
// -> true
console.log(object1 == object3);
// -> false

'object2' is set to equal 'object1', which gives it the same identity. 

const binding to an object allows the values to change but the binding to the object itself cannot change

const score = {visitors: 0, home: 0};
score.visitors = 1;

//error
score = {visitor: 1, home: 1};
- - - - - - - - - - - -  - - - -
//empty array
let jounral = []; 

function addEntry(events, squirrel) {
  journal.push({events, squirrel});
}

Note that the object added to the journal looks a little odd. Instead of declaring properties like events: events, it just gives a property name. This is shorthand that means the same thing—if a property name in brace notation isn’t followed by a value, its value is taken from the binding with the same name.

//Array Loops
for (let i = 0; i < journal.length; i++) {
  let entry = journal[i];
}
//mordern loop in JS
for (let entry of journal) {
  console.log(`${entry.events.length} events.`)
}

//CHAPTER 5

//reduce()

const array1 = [1, 2, 3, 4];
let reducer = (accumulator, currentValue) => accumulator + currentValue;

// 1 + 2 + 3 + 4
console.log(array1.reduce(reducer));
// -> 10

// 5 + 1 + 2 + 3 + 4
console.log(array1.reduce(reducer, 5));
// ->  15

- - - - - - - - - - - - -

let vals = [5, 4, 1, 2, 9];
let acc = 0;
for (let val of vals) {
  acc += val;
}
console.log(acc);
// -> 21

function sum(acc, val) {   arrow function  (acc, val) => acc + val
  return acc + val;           ---- > 
}  

let answer = vals.reduce(sum);
let answer = vals.reduce((acc, val) => acc + val);
console.log(answer);
// -> 21

let answer10 = vals.reduce(sum, 10);
console.log(answer10);
// -> 31

let answer10 = vals.reduce((acc, val) => {
  return acc + val
}, 10)
// -> 31
- - - - - - - - - - - - -


function reduce(array, combine, start) {
  let current = start;
  for (let element of array) {
    current = combine(current, element);
  }
  return current;
}

console.log(reduce([1, 2, 3, 4], (a, b) => a + b, 0));
// -> 10

- - - - - - - - - - - - - - - -

//flatten an array of arrays
let flattened = [[0, 1], [2, 3], [4, 5]].reduce (
  function(accumulator, currentValue) {
    return accumulator.concat(currentValue)
  }, []);

let flattened = [[0, 1], [2, 3], [4, 5]].reduce (
  (accumulator, currentValue) => accumulator.concat(currentValue), 
  [])

- - - - - - - - - - - - - - - -

If no initial value is given, the first element of the array will be the accumulator.

accumulator is the result of the loop.
[2,1,4,5,9,7]
let biggest = vals.reduce((a, b) => b > a ? b : a);

Step 1: accumulator is 2 (because no initial value)
Step 2: is 1 > 2? no. accumulator remains 2;
step 3: is 4 > 2? yes. accumulator is now 4;
step 5: is 5 > 4? yes. accumulator is now 5;
step 6: is 9 > 5? yes, accumulator is now 9;
step 7: is 7 > 9? no. accumulator remains 9;
